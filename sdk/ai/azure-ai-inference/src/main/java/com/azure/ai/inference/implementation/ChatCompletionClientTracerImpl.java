// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.inference.implementation;

import com.azure.ai.inference.models.ChatChoice;
import com.azure.ai.inference.models.ChatCompletions;
import com.azure.ai.inference.models.ChatCompletionsOptions;
import com.azure.ai.inference.models.ChatCompletionsToolCall;
import com.azure.ai.inference.models.ChatRequestMessage;
import com.azure.ai.inference.models.ChatRole;
import com.azure.ai.inference.models.CompletionsFinishReason;
import com.azure.ai.inference.models.CompletionsUsage;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.CoreUtils;
import com.azure.core.util.logging.ClientLogger;
import com.azure.core.util.tracing.SpanKind;
import com.azure.core.util.tracing.StartSpanOptions;
import com.azure.core.util.tracing.Tracer;
import com.azure.core.util.tracing.TracerProvider;
import com.azure.json.JsonProviders;
import com.azure.json.JsonWriter;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// ChatCompletionClientTracerImpl is the SDK owner implementation for the auto generated contract ChatCompletionClientTracer.
public final class ChatCompletionClientTracerImpl implements ChatCompletionClientTracer {
    private final ClientLogger logger;
    private final boolean traceContent = true; // make it configurable (com.azure.core.util.Configuration?)
    private final URL endpoint;
    private final Tracer tracer;

    public ChatCompletionClientTracerImpl() {
        this.logger = new ClientLogger(ChatCompletionClientTracerImpl.class);
        this.endpoint = null;
        this.tracer = TracerProvider.getDefaultProvider().createTracer(CLIENT_NAME, CLIENT_VERSION, "Azure.AI", null);
    }

    /**
    public ChatCompletionClientTracerImpl(String endpoint, com.azure.core.util.ClientOptions clientOptions) {
        this.logger = new ClientLogger(ChatCompletionClientTracerImpl.class);
        this.endpoint = parse(endpoint, logger);
        final com.azure.core.util.TracingOptions tracingOptions = clientOptions == null ? null : clientOptions.getTracingOptions();
        this.tracer
            = TracerProvider.getDefaultProvider().createTracer(CLIENT_NAME, CLIENT_VERSION, "Azure.AI", tracingOptions);
    }
    **/

    @Override
    public ChatCompletions traceComplete(ChatCompletionsOptions request, CompleteOperation operation,
        BinaryData completeRequest, RequestOptions requestOptions, Context parent) {
        if (!tracer.isEnabled()) {
            return operation.invoke(completeRequest, requestOptions.setContext(parent));
        }
        final Context span = tracer.start(rootSpanName(request), new StartSpanOptions(SpanKind.CLIENT), parent);
        traceCompletionRequestAttributes(request, span);
        traceCompletionRequestEvents(request.getMessages(), span);

        try (AutoCloseable ignored = tracer.makeSpanCurrent(span)) {
            final ChatCompletions response = operation.invoke(completeRequest, requestOptions.setContext(span));
            traceCompletionResponseAttributes(response, ignored, span);
            traceCompletionResponseEvents(response, span);
            tracer.end(null, null, span);
            return response;
        } catch (Exception e) {
            tracer.end(null, e, span);
            throw asRuntimeException(e);
        }
    }

    private String rootSpanName(ChatCompletionsOptions completeRequest) {
        return CoreUtils.isNullOrEmpty(completeRequest.getModel()) ? "chat" : "chat " + completeRequest.getModel();
    }

    private void traceCompletionRequestAttributes(ChatCompletionsOptions request, Context span) {
        final String modelId = request.getModel();
        tracer.setAttribute("gen_ai.operation.name", "chat", span);
        tracer.setAttribute("gen_ai.system", INFERENCE_GEN_AI_SYSTEM_NAME, span);
        tracer.setAttribute("gen_ai.request.model", CoreUtils.isNullOrEmpty(modelId) ? "chat" : modelId, span);
        if (request.getMaxTokens() != null) {
            tracer.setAttribute("gen_ai.request.max_tokens", request.getMaxTokens(), span);
        }
        if (request.getTemperature() != null) {
            tracer.setAttribute("gen_ai.request.temperature", request.getTemperature(), span);
        }
        if (request.getTopP() != null) {
            tracer.setAttribute("gen_ai.request.top_p", request.getTopP(), span);
        }
        if (endpoint != null) {
            tracer.setAttribute("server.address", endpoint.getHost(), span);
            if (endpoint.getPort() != 443) {
                tracer.setAttribute("server.port", endpoint.getPort(), span);
            }
        }
    }

    private void traceCompletionRequestEvents(List<ChatRequestMessage> messages, Context span) {
        if (!traceContent) {
            return;
        }
        if (messages != null) {
            for (ChatRequestMessage message : messages) {
                final ChatRole role = message.getRole();
                if (role != null) {
                    final String eventName = "gen_ai." + role.getValue() + ".message";
                    final String eventContent = toJsonString(message);
                    if (eventContent != null) {
                        final Map<String, Object> eventAttributes = new HashMap<>(2);
                        eventAttributes.put("gen_ai.system", INFERENCE_GEN_AI_SYSTEM_NAME);
                        eventAttributes.put("gen_ai.event.content", eventContent);
                        tracer.addEvent(eventName, eventAttributes, OffsetDateTime.now(ZoneOffset.UTC), span);
                    }
                }
            }
        }
    }

    private void traceCompletionResponseAttributes(ChatCompletions response, AutoCloseable ignored, Context span) {
        tracer.setAttribute("gen_ai.response.id", response.getId(), span);
        tracer.setAttribute("gen_ai.response.model", response.getModel(), span);
        final CompletionsUsage usage = response.getUsage();
        if (usage != null) {
            tracer.setAttribute("gen_ai.usage.input_tokens", usage.getPromptTokens(), span);
            tracer.setAttribute("gen_ai.usage.output_tokens", usage.getCompletionTokens(), span);
        }
        final List<ChatChoice> choices = response.getChoices();
        if (choices != null) {
            tracer.setAttribute("gen_ai.response.finish_reasons", getFinishReasons(choices), span);
        }
    }

    private void traceCompletionResponseEvents(ChatCompletions response, Context span) {
        final List<ChatChoice> choices = response.getChoices();
        if (choices != null) {
            tracer.setAttribute("gen_ai.response.finish_reasons", getFinishReasons(choices), span);
            final OffsetDateTime now = OffsetDateTime.now(ZoneOffset.UTC);
            for (ChatChoice choice : choices) {
                final Map<String, Object> eventAttributes = new HashMap<>(2);
                eventAttributes.put("gen_ai.system", INFERENCE_GEN_AI_SYSTEM_NAME);
                eventAttributes.put("gen_ai.event.content", toJsonString(choice));
                tracer.addEvent("gen_ai.choice", eventAttributes, now, span);
            }
        }
    }

    private String toJsonString(ChatRequestMessage message) {
        try (ByteArrayOutputStream stream = new ByteArrayOutputStream();
            JsonWriter writer = JsonProviders.createWriter(stream)) {
            message.toJson(writer);
            writer.flush();
            return new String(stream.toByteArray(), StandardCharsets.UTF_8);
        } catch (IOException e) {
            logger.atWarning().log("'ChatRequestMessage' serialization error", e);
        }
        return null;
    }

    private String toJsonString(ChatChoice choice) {
        try (ByteArrayOutputStream stream = new ByteArrayOutputStream();
            JsonWriter writer = JsonProviders.createWriter(stream)) {
            writer.writeStartObject();
            writer.writeStartObject("message");
            if (traceContent) {
                writer.writeStringField("content", choice.getMessage().getContent());
            }
            if (choice.getMessage() != null) {
                final List<ChatCompletionsToolCall> toolCalls = choice.getMessage().getToolCalls();
                if (toolCalls != null && !toolCalls.isEmpty()) {
                    writer.writeStartArray("tool_calls");
                    for (ChatCompletionsToolCall toolCall : toolCalls) {
                        if (traceContent) {
                            toolCall.toJson(writer);
                        } else {
                            writer.writeStartObject();
                            writer.writeStringField("id", toolCall.getId());
                            writer.writeStringField("type", toolCall.getType());
                            writer.writeEndObject();
                        }
                    }
                    writer.writeEndArray();
                }
            }
            writer.writeEndObject();
            final CompletionsFinishReason finishReason = choice.getFinishReason();
            if (finishReason != null) {
                writer.writeStringField("finish_reason", finishReason.getValue());
            }
            writer.writeIntField("index", choice.getIndex());
            writer.writeEndObject();
            writer.flush();
            return new String(stream.toByteArray(), StandardCharsets.UTF_8);
        } catch (IOException e) {
            logger.atWarning().log("'ChatChoice' serialization error", e);
        }
        return null;
    }

    private static String getFinishReasons(List<ChatChoice> choices) {
        final StringBuilder finishReasons = new StringBuilder("[");
        for (ChatChoice choice : choices) {
            final CompletionsFinishReason finishReason = choice.getFinishReason();
            if (finishReason == null) {
                finishReasons.append("none");
            } else {
                finishReasons.append(finishReason.getValue());
            }
            finishReasons.append(", ");
        }
        finishReasons.append("]");
        return finishReasons.toString();
    }

    private static URL parse(String endpoint, ClientLogger logger) {
        try {
            final URI uri = new URI(endpoint);
            return uri.toURL();
        } catch (MalformedURLException | URISyntaxException e) {
            logger.atWarning().log("service endpoint uri parse error.", e);
        }
        return null;
    }

    private static RuntimeException asRuntimeException(Exception e) {
        if (e instanceof RuntimeException) {
            return (RuntimeException) e;
        } else {
            return new RuntimeException(e);
        }
    }
}
