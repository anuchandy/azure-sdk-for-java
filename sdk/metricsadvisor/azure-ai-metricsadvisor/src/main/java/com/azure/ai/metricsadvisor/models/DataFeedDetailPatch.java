// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.ai.metricsadvisor.models;

import com.azure.ai.metricsadvisor.implementation.util.Option;
import com.azure.core.annotation.Fluent;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;

import java.time.OffsetDateTime;
import java.util.List;

/** The DataFeedDetailPatch model. */
@JsonTypeInfo(
        use = JsonTypeInfo.Id.NAME,
        include = JsonTypeInfo.As.PROPERTY,
        property = "dataSourceType",
        defaultImpl = DataFeedDetailPatch.class)
@JsonTypeName("DataFeedDetailPatch")
@JsonSubTypes({
    @JsonSubTypes.Type(name = "AzureApplicationInsights", value = AzureApplicationInsightsDataFeedPatch.class),
    @JsonSubTypes.Type(name = "AzureBlob", value = AzureBlobDataFeedPatch.class),
    @JsonSubTypes.Type(name = "AzureCosmosDB", value = AzureCosmosDBDataFeedPatch.class),
    @JsonSubTypes.Type(name = "AzureDataExplorer", value = AzureDataExplorerDataFeedPatch.class),
    @JsonSubTypes.Type(name = "AzureDataLakeStorageGen2", value = AzureDataLakeStorageGen2DataFeedPatch.class),
    @JsonSubTypes.Type(name = "AzureEventHubs", value = AzureEventHubsDataFeedPatch.class),
    @JsonSubTypes.Type(name = "AzureLogAnalytics", value = AzureLogAnalyticsDataFeedPatch.class),
    @JsonSubTypes.Type(name = "AzureTable", value = AzureTableDataFeedPatch.class),
    @JsonSubTypes.Type(name = "InfluxDB", value = InfluxDBDataFeedPatch.class),
    @JsonSubTypes.Type(name = "MySql", value = MySqlDataFeedPatch.class),
    @JsonSubTypes.Type(name = "PostgreSql", value = PostgreSqlDataFeedPatch.class),
    @JsonSubTypes.Type(name = "SqlServer", value = SQLServerDataFeedPatch.class),
    @JsonSubTypes.Type(name = "MongoDB", value = MongoDBDataFeedPatch.class)
})
@Fluent
public class DataFeedDetailPatch {
    /*
     * data feed name
     */
    @JsonProperty(value = "dataFeedName")
    private Option<String> dataFeedName;

    /*
     * data feed description
     */
    @JsonProperty(value = "dataFeedDescription")
    private Option<String> dataFeedDescription;

    /*
     * user-defined timestamp column. if timestampColumn is null, start time of
     * every time slice will be used as default value.
     */
    @JsonProperty(value = "timestampColumn")
    private Option<String> timestampColumn;

    /*
     * ingestion start time
     */
    @JsonProperty(value = "dataStartFrom")
    private Option<OffsetDateTime> dataStartFrom;

    /*
     * the time that the beginning of data ingestion task will delay for every
     * data slice according to this offset.
     */
    @JsonProperty(value = "startOffsetInSeconds")
    private Option<Long> startOffsetInSeconds;

    /*
     * the max concurrency of data ingestion queries against user data source.
     * 0 means no limitation.
     */
    @JsonProperty(value = "maxConcurrency")
    private Option<Integer> maxConcurrency;

    /*
     * the min retry interval for failed data ingestion tasks.
     */
    @JsonProperty(value = "minRetryIntervalInSeconds")
    private Option<Long> minRetryIntervalInSeconds;

    /*
     * stop retry data ingestion after the data slice first schedule time in
     * seconds.
     */
    @JsonProperty(value = "stopRetryAfterInSeconds")
    private Option<Long> stopRetryAfterInSeconds;

    /*
     * mark if the data feed need rollup
     */
    @JsonProperty(value = "needRollup")
    private Option<DataFeedRollupType> needRollup;

    /*
     * roll up method
     */
    @JsonProperty(value = "rollUpMethod")
    private Option<DataFeedAutoRollUpMethod> rollUpMethod;

    /*
     * roll up columns
     */
    @JsonProperty(value = "rollUpColumns")
    private Option<List<String>> rollUpColumns;

    /*
     * the identification value for the row of calculated all-up value.
     */
    @JsonProperty(value = "allUpIdentification")
    private Option<String> allUpIdentification;

    /*
     * the type of fill missing point for anomaly detection
     */
    @JsonProperty(value = "fillMissingPointType")
    private Option<DataFeedMissingDataPointFillType> fillMissingPointType;

    /*
     * the value of fill missing point for anomaly detection
     */
    @JsonProperty(value = "fillMissingPointValue")
    private Option<Double> fillMissingPointValue;

    /*
     * data feed access mode, default is Private
     */
    @JsonProperty(value = "viewMode")
    private Option<DataFeedAccessMode> viewMode;

    /*
     * data feed administrator
     */
    @JsonProperty(value = "admins")
    private Option<List<String>> admins;

    /*
     * data feed viewer
     */
    @JsonProperty(value = "viewers")
    private Option<List<String>> viewers;

    /*
     * data feed status
     */
    @JsonProperty(value = "status")
    private Option<DataFeedStatus> status;

    /*
     * action link for alert
     */
    @JsonProperty(value = "actionLinkTemplate")
    private Option<String> actionLinkTemplate;

    /*
     * authentication type for corresponding data source
     */
    @JsonProperty(value = "authenticationType")
    private Option<DatasourceAuthenticationType> authenticationType;

    /*
     * The credential entity id
     */
    @JsonProperty(value = "credentialId")
    private Option<String> credentialId;

    /**
     * Get the dataFeedName property: data feed name.
     *
     * @return the dataFeedName value.
     */
    String getDataFeedName() {
        if (this.dataFeedName != null) {
            this.dataFeedName.getValue();
        }
        return null;
    }

    /**
     * Set the dataFeedName property: data feed name.
     *
     * @param dataFeedName the dataFeedName value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setDataFeedName(String dataFeedName) {
        if (dataFeedName == null) {
            this.dataFeedName = Option.empty();
        } else {
            this.dataFeedName = Option.of(dataFeedName);
        }
        return this;
    }

    /**
     * Get the dataFeedDescription property: data feed description.
     *
     * @return the dataFeedDescription value.
     */
    String getDataFeedDescription() {
        if (this.dataFeedDescription != null) {
            this.dataFeedDescription.getValue();
        }
        return null;
    }

    /**
     * Set the dataFeedDescription property: data feed description.
     *
     * @param dataFeedDescription the dataFeedDescription value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setDataFeedDescription(String dataFeedDescription) {
        if (dataFeedDescription == null) {
            this.dataFeedDescription = Option.empty();
        } else {
            this.dataFeedDescription = Option.of(dataFeedDescription);
        }
        return this;
    }

    /**
     * Get the timestampColumn property: user-defined timestamp column. if timestampColumn is null, start time of every
     * time slice will be used as default value.
     *
     * @return the timestampColumn value.
     */
    String getTimestampColumn() {
        if (this.timestampColumn != null) {
            this.timestampColumn.getValue();
        }
        return null;
    }

    /**
     * Set the timestampColumn property: user-defined timestamp column. if timestampColumn is null, start time of every
     * time slice will be used as default value.
     *
     * @param timestampColumn the timestampColumn value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setTimestampColumn(String timestampColumn) {
        if (timestampColumn == null) {
            this.timestampColumn = Option.empty();
        } else {
            this.timestampColumn = Option.of(timestampColumn);
        }
        return this;
    }

    /**
     * Get the dataStartFrom property: ingestion start time.
     *
     * @return the dataStartFrom value.
     */
    OffsetDateTime getDataStartFrom() {
        if (this.dataStartFrom != null) {
            this.dataStartFrom.getValue();
        }
        return null;
    }

    /**
     * Set the dataStartFrom property: ingestion start time.
     *
     * @param dataStartFrom the dataStartFrom value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setDataStartFrom(OffsetDateTime dataStartFrom) {
        if (dataStartFrom == null) {
            this.dataStartFrom = Option.empty();
        } else {
            this.dataStartFrom = Option.of(dataStartFrom);
        }
        return this;
    }

    /**
     * Get the startOffsetInSeconds property: the time that the beginning of data ingestion task will delay for every
     * data slice according to this offset.
     *
     * @return the startOffsetInSeconds value.
     */
    Long getStartOffsetInSeconds() {
        if (this.startOffsetInSeconds != null) {
            this.startOffsetInSeconds.getValue();
        }
        return null;
    }

    /**
     * Set the startOffsetInSeconds property: the time that the beginning of data ingestion task will delay for every
     * data slice according to this offset.
     *
     * @param startOffsetInSeconds the startOffsetInSeconds value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setStartOffsetInSeconds(Long startOffsetInSeconds) {
        if (startOffsetInSeconds == null) {
            this.startOffsetInSeconds = Option.empty();
        } else {
            this.startOffsetInSeconds = Option.of(startOffsetInSeconds);
        }
        return this;
    }

    /**
     * Get the maxConcurrency property: the max concurrency of data ingestion queries against user data source. 0 means
     * no limitation.
     *
     * @return the maxConcurrency value.
     */
    Integer getMaxConcurrency() {
        if (this.maxConcurrency != null) {
            this.maxConcurrency.getValue();
        }
        return null;
    }

    /**
     * Set the maxConcurrency property: the max concurrency of data ingestion queries against user data source. 0 means
     * no limitation.
     *
     * @param maxConcurrency the maxConcurrency value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setMaxConcurrency(Integer maxConcurrency) {
        if (maxConcurrency == null) {
            this.maxConcurrency = Option.empty();
        } else {
            this.maxConcurrency = Option.of(maxConcurrency);
        }
        return this;
    }

    /**
     * Get the minRetryIntervalInSeconds property: the min retry interval for failed data ingestion tasks.
     *
     * @return the minRetryIntervalInSeconds value.
     */
    Long getMinRetryIntervalInSeconds() {
        if (this.minRetryIntervalInSeconds != null) {
            this.minRetryIntervalInSeconds.getValue();
        }
        return null;
    }

    /**
     * Set the minRetryIntervalInSeconds property: the min retry interval for failed data ingestion tasks.
     *
     * @param minRetryIntervalInSeconds the minRetryIntervalInSeconds value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setMinRetryIntervalInSeconds(Long minRetryIntervalInSeconds) {
        if (minRetryIntervalInSeconds == null) {
            this.minRetryIntervalInSeconds = Option.empty();
        } else {
            this.minRetryIntervalInSeconds = Option.of(minRetryIntervalInSeconds);
        }
        return this;
    }

    /**
     * Get the stopRetryAfterInSeconds property: stop retry data ingestion after the data slice first schedule time in
     * seconds.
     *
     * @return the stopRetryAfterInSeconds value.
     */
    Long getStopRetryAfterInSeconds() {
        if (this.stopRetryAfterInSeconds != null) {
            this.stopRetryAfterInSeconds.getValue();
        }
        return null;
    }

    /**
     * Set the stopRetryAfterInSeconds property: stop retry data ingestion after the data slice first schedule time in
     * seconds.
     *
     * @param stopRetryAfterInSeconds the stopRetryAfterInSeconds value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setStopRetryAfterInSeconds(Long stopRetryAfterInSeconds) {
        if (stopRetryAfterInSeconds == null) {
            this.stopRetryAfterInSeconds = Option.empty();
        } else {
            this.stopRetryAfterInSeconds = Option.of(stopRetryAfterInSeconds);
        }
        return this;
    }

    /**
     * Get the needRollup property: mark if the data feed need rollup.
     *
     * @return the needRollup value.
     */
    DataFeedRollupType getNeedRollup() {
        if (this.needRollup != null) {
            this.needRollup.getValue();
        }
        return null;
    }

    /**
     * Set the needRollup property: mark if the data feed need rollup.
     *
     * @param needRollup the needRollup value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setNeedRollup(DataFeedRollupType needRollup) {
        if (needRollup == null) {
            this.needRollup = Option.empty();
        } else {
            this.needRollup = Option.of(needRollup);
        }
        return this;
    }

    /**
     * Get the rollUpMethod property: roll up method.
     *
     * @return the rollUpMethod value.
     */
    DataFeedAutoRollUpMethod getRollUpMethod() {
        if (this.rollUpMethod != null) {
            this.rollUpMethod.getValue();
        }
        return null;
    }

    /**
     * Set the rollUpMethod property: roll up method.
     *
     * @param rollUpMethod the rollUpMethod value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setRollUpMethod(DataFeedAutoRollUpMethod rollUpMethod) {
        if (rollUpMethod == null) {
            this.rollUpMethod = Option.empty();
        } else {
            this.rollUpMethod = Option.of(rollUpMethod);
        }
        return this;
    }

    /**
     * Get the rollUpColumns property: roll up columns.
     *
     * @return the rollUpColumns value.
     */
    List<String> getRollUpColumns() {
        if (this.rollUpColumns != null) {
            this.rollUpColumns.getValue();
        }
        return null;
    }

    /**
     * Set the rollUpColumns property: roll up columns.
     *
     * @param rollUpColumns the rollUpColumns value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setRollUpColumns(List<String> rollUpColumns) {
        if (rollUpColumns == null) {
            this.rollUpColumns = Option.empty();
        } else {
            this.rollUpColumns = Option.of(rollUpColumns);
        }
        return this;
    }

    /**
     * Get the allUpIdentification property: the identification value for the row of calculated all-up value.
     *
     * @return the allUpIdentification value.
     */
    String getAllUpIdentification() {
        if (this.allUpIdentification != null) {
            this.allUpIdentification.getValue();
        }
        return null;
    }

    /**
     * Set the allUpIdentification property: the identification value for the row of calculated all-up value.
     *
     * @param allUpIdentification the allUpIdentification value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setAllUpIdentification(String allUpIdentification) {
        if (allUpIdentification == null) {
            this.allUpIdentification = Option.empty();
        } else {
            this.allUpIdentification = Option.of(allUpIdentification);
        }
        return this;
    }

    /**
     * Get the fillMissingPointType property: the type of fill missing point for anomaly detection.
     *
     * @return the fillMissingPointType value.
     */
    DataFeedMissingDataPointFillType getFillMissingPointType() {
        if (this.fillMissingPointType != null) {
            this.fillMissingPointType.getValue();
        }
        return null;
    }

    /**
     * Set the fillMissingPointType property: the type of fill missing point for anomaly detection.
     *
     * @param fillMissingPointType the fillMissingPointType value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setFillMissingPointType(DataFeedMissingDataPointFillType fillMissingPointType) {
        if (fillMissingPointType == null) {
            this.fillMissingPointType = Option.empty();
        } else {
            this.fillMissingPointType = Option.of(fillMissingPointType);
        }
        return this;
    }

    /**
     * Get the fillMissingPointValue property: the value of fill missing point for anomaly detection.
     *
     * @return the fillMissingPointValue value.
     */
    Double getFillMissingPointValue() {
        if (this.fillMissingPointValue != null) {
            this.fillMissingPointValue.getValue();
        }
        return null;
    }

    /**
     * Set the fillMissingPointValue property: the value of fill missing point for anomaly detection.
     *
     * @param fillMissingPointValue the fillMissingPointValue value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setFillMissingPointValue(Double fillMissingPointValue) {
        if (fillMissingPointValue == null) {
            this.fillMissingPointValue = Option.empty();
        } else {
            this.fillMissingPointValue = Option.of(fillMissingPointValue);
        }
        return this;
    }

    /**
     * Get the viewMode property: data feed access mode, default is Private.
     *
     * @return the viewMode value.
     */
    DataFeedAccessMode getViewMode() {
        if (this.viewMode != null) {
            this.viewMode.getValue();
        }
        return null;
    }

    /**
     * Set the viewMode property: data feed access mode, default is Private.
     *
     * @param viewMode the viewMode value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setViewMode(DataFeedAccessMode viewMode) {
        if (viewMode == null) {
            this.viewMode = Option.empty();
        } else {
            this.viewMode = Option.of(viewMode);
        }
        return this;
    }

    /**
     * Get the admins property: data feed administrator.
     *
     * @return the admins value.
     */
    List<String> getAdmins() {
        if (this.admins != null) {
            this.admins.getValue();
        }
        return null;
    }

    /**
     * Set the admins property: data feed administrator.
     *
     * @param admins the admins value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setAdmins(List<String> admins) {
        if (admins == null) {
            this.admins = Option.empty();
        } else {
            this.admins = Option.of(admins);
        }
        return this;
    }

    /**
     * Get the viewers property: data feed viewer.
     *
     * @return the viewers value.
     */
    List<String> getViewers() {
        if (this.viewers != null) {
            this.viewers.getValue();
        }
        return null;
    }

    /**
     * Set the viewers property: data feed viewer.
     *
     * @param viewers the viewers value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setViewers(List<String> viewers) {
        if (viewers == null) {
            this.viewers = Option.empty();
        } else {
            this.viewers = Option.of(viewers);
        }
        return this;
    }

    /**
     * Get the status property: data feed status.
     *
     * @return the status value.
     */
    DataFeedStatus getStatus() {
        if (this.status != null) {
            this.status.getValue();
        }
        return null;
    }

    /**
     * Set the status property: data feed status.
     *
     * @param status the status value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setStatus(DataFeedStatus status) {
        if (status == null) {
            this.status = Option.empty();
        } else {
            this.status = Option.of(status);
        }
        return this;
    }

    /**
     * Get the actionLinkTemplate property: action link for alert.
     *
     * @return the actionLinkTemplate value.
     */
    String getActionLinkTemplate() {
        if (this.actionLinkTemplate != null) {
            this.actionLinkTemplate.getValue();
        }
        return null;
    }

    /**
     * Set the actionLinkTemplate property: action link for alert.
     *
     * @param actionLinkTemplate the actionLinkTemplate value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setActionLinkTemplate(String actionLinkTemplate) {
        if (actionLinkTemplate == null) {
            this.actionLinkTemplate = Option.empty();
        } else {
            this.actionLinkTemplate = Option.of(actionLinkTemplate);
        }
        return this;
    }

    /**
     * Get the authenticationType property: authentication type for corresponding data source.
     *
     * @return the authenticationType value.
     */
    DatasourceAuthenticationType getAuthenticationType() {
        if (this.authenticationType != null) {
            this.authenticationType.getValue();
        }
        return null;
    }

    /**
     * Set the authenticationType property: authentication type for corresponding data source.
     *
     * @param authenticationType the authenticationType value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setAuthenticationType(DatasourceAuthenticationType authenticationType) {
        if (authenticationType == null) {
            this.authenticationType = Option.empty();
        } else {
            this.authenticationType = Option.of(authenticationType);
        }
        return this;
    }

    /**
     * Get the credentialId property: The credential entity id.
     *
     * @return the credentialId value.
     */
    String getCredentialId() {
        if (this.credentialId != null) {
            this.credentialId.getValue();
        }
        return null;
    }

    /**
     * Set the credentialId property: The credential entity id.
     *
     * @param credentialId the credentialId value to set.
     * @return the DataFeedDetailPatch object itself.
     */
    public DataFeedDetailPatch setCredentialId(String credentialId) {
        if (credentialId == null) {
            this.credentialId = Option.empty();
        } else {
            this.credentialId = Option.of(credentialId);
        }
        return this;
    }
}
